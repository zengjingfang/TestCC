## C++内存分配秘籍—new，malloc，GlobalAlloc详解


> 本篇完全抄录：https://www.cnblogs.com/gaochaooo/archive/2009/09/03/1559764.html

一。关于内存

　1、内存分配方式

　　内存分配方式有三种：

　　（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在

。例如全局变量，static变量。

　　（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存

储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　　（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自

己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

   2.内存使用错误
     　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。

而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有

发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：
       * 内存分配未成功，却使用了它。

　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查

指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。

　　* 内存分配虽然成功，但是尚未初始化就引用它。

　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值

错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不

可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

　　* 内存分配成功并且已经初始化，但操作越过了内存的边界。

　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞

错，导致数组操作越界。

　　* 忘记了释放内存，造成内存泄露。

　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次

程序突然死掉，系统出现提示：内存耗尽。

　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误

（new/delete同理）。

　　* 释放了内存却继续使用它。
　
　　有三种情况：

　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新

设计数据结构，从根本上解决对象管理的混乱局面。

　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函

数体结束时被自动销毁。

　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。

　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存

　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。

　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。


二. 详解new，malloc，GlobalAlloc

 1.  new

  new和delete运算符用于动态分配和撤销内存的运算符

new用法:

          1>     开辟单变量地址空间

               1)new int;  //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new

int 即为将一个int类型的地址赋值给整型指针a.

               2)int *a = new int(5) 作用同上,但是同时将整数赋值为5

          2>    开辟数组空间

               一维: int *a = new int[100];开辟一个大小为100的整型数组空间

         一般用法: new 类型 [初值]

delete用法:

          1> int *a = new int;

               delete a;   //释放单个int的空间

          2>int *a = new int[5];

               delete [] a; //释放int数组空间

          要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问.

          用new和delete可以动态开辟,撤销地址空间.在编程序时,若用完一个变量(一般是暂时存储的数组),

下次需要再用,但却又想省去重新初始化的功夫,可以在每次开始使用时开辟一个空间,在用完后撤销它.

2.  malloc
  原型：extern void *malloc(unsigned int num_bytes);
　　用法：＃i nclude <malloc.h>或＃i nclude <stdlib.h>
　　功能：分配长度为num_bytes字节的内存块
　　说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。
　　当内存不再使用时，应使用free()函数将内存块释放。
　　malloc的语法是：指针名=（数据类型*）malloc（长度）,（数据类型*）表示指针.
说明：malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型

的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。

malloc（）函数的工作机制
　　malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc

函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大

小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并

将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到

最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以

满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们

进行整理，将相邻的小空闲块合并成较大的内存块。

和new的不同
从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需

要大小。比如：
int *p;
p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);
或：
int* parr;
parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;
而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。
int* p;
p = (int *) malloc (sizeof(int));
第一、malloc 函数返回的是 void * 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，

报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。
第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成：
int* p = (int *) malloc (1);
代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无

家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。


3.  GlobalAlloc

   VC中关于GlobalAlloc，GlobalLock，GlobalUnLock

调用GlobalAlloc函数分配一块内存，该函数会返回分配的内存句柄。
调用GlobalLock函数锁定内存块，该函数接受一个内存句柄作为参数，然后返回一个指向被锁定的内存块的指

针。 您可以用该指针来读写内存。
调用GlobalUnlock函数来解锁先前被锁定的内存，该函数使得指向内存块的指针无效。
调用GlobalFree函数来释放内存块。您必须传给该函数一个内存句柄。

GlobalAlloc
说明
分配一个全局内存块
返回值
Long，返回全局内存句柄。零表示失败。会设置GetLastError
参数表
参数 类型及说明
wFlags Long，对分配的内存类型进行定义的常数标志，如下所示：
             GMEM_FIXED 分配一个固定内存块
             GMEM_MOVEABLE 分配一个可移动内存块
             GMEM_DISCARDABLE 分配一个可丢弃内存块
             GMEM_NOCOMPACT 堆在这个函数调用期间不进行累积
             GMEM_NODISCARD 函数调用期间不丢弃任何内存块
             GMEM_ZEROINIT 新分配的内存块全部初始化成零
dwBytes Long，要分配的字符数

  GlobalLock
函数功能描述:锁定一个全局的内存对象，返回指向该对象的第一个字节的指针
函数原型：
LPVOID GlobalLock( HGLOBAL hMem )
参数：
hMem：全局内存对象的句柄。这个句柄是通过GlobalAlloc或GlobalReAlloc来得到的
返回值：
调用成功，返回指向该对象的第一个字节的指针
调用失败，返回NULL，可以用GetLastError来获得出错信息
注意：
调用过GlobalLock锁定一块内存区后，一定要调用GlobalUnlock来解锁

  GlobalUnlock
函数功能描述:解除被锁定的全局内存对象
函数原型：BOOL GlobalUnlock( HGLOBAL hMem );
参数：hMem：全局内存对象的句柄
返回值：
非零值，指定的内存对象仍处于被锁定状态
0，函数执行出错，可以用GetLastError来获得出错信息，如果返回NO_ERROR，则表示内存对象已经解锁了
注意：    这个函数实际上是将内存对象的锁定计数器减一，如果计数器不为0，则表示执行过多个GlobalLock

函数来对这个内存对象加锁，需要对应数目的GlobalUnlock函数来解锁。如果通过GetLastError函数返回错误

码为ERROR_NOT_LOCKED，则表示未加锁或已经解锁。

  示例：
// Malloc memory
hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, nSize);
// Lock memory
pMem = (BYTE *) GlobalLock(hMem);
..................
// Unlock memory
GlobalUnlock(hMem);
GlobalFree(hMem);

三 总结

灵活自由是C/C++语言的一大特色，而这也为C/C++程序员出了一个难题。当程序越来越复杂时，内存的管理也

会变得越加复杂，稍有不慎就会出现内存问 题。内存泄漏是最常见的内存问题之一。内存泄漏如果不是很严重

，在短时间内对程序不会有太大的影响，这也使得内存泄漏问题有很强的隐蔽性，不容易被发现。 然而不管内

存泄漏多么轻微，当程序长时间运行时，其破坏力是惊人的，从性能下降到内存耗尽，甚至会影响到其他程序

的正常运行。另外内存问题的一个共同特点 是，内存问题本身并不会有很明显的现象，当有异常现象出现时已

时过境迁，其现场已非出现问题时的现场了，这给调试内存问题带来了很大的难度。

 下载Windows Debug 工具, http://www.microsoft.com/whdc/devtools/debugging/default.mspx
安装后,使用其中的gflags.exe工具打开PageHeap,
gflags -p /enable MainD.exe /full
重新使用VS用调试方式运行,很快就找到了出错位置,因为在某个静态函数中笔误导致

在编写稳定的服务器程序时,这个工具尤为有用。



参考文献及网页地址：
1. http://www.bccn.net/Article/kfyy/cjj/jszl/200607/4172.html
2. http://www.7880.com/Info/Article-8282a500.html
3. http://www.cnblogs.com/jjzhou1988/archive/2008/11/30/1344314.html
4. http://blog.chinaunix.net/u3/101356/showart_2031203.html
5. http://www.cnblogs.com/howareyou586/archive/2008/11/06/1328353.html